---
title: "De GitHub Copilot à Claude Code : 4 ans d’évolution du développement avec l’IA"
slug: "from-copilot-to-claude"
date: "2026-02-25"
tags: ["IA", "Claude Code", "Cursor", "GitHub Copilot"]
summary: "Retour d’expérience après 4 ans à développer avec l’IA : GitHub Copilot, Cursor et Claude Code. Productivité, développement agentique et évolution du métier de développeur."
readingTime: 5
---

Il y a un peu plus de quatre ans, j’ai lancé GitHub Copilot pour la première fois. Curieux mais sceptique, je ne croyais pas qu’il allait transformer ma façon de coder.

J’avais tort. Mais pas du tout pour les raisons que j’imaginais.

<Timeline items={[
  { year: "2022", tool: "GitHub Copilot", desc: "L'autocomplétion intelligente. Promesse séduisante, tenue à moitié." },
  { year: "2023", tool: "Cursor", desc: "Le mode conversation. Un vrai changement de paradigme." },
  { year: "2025–", tool: "Claude Code", desc: "Le développement agentique. Un autre métier." }
]} />

## GitHub Copilot : le faux ami de la productivité ?

En 2022, Copilot c'était essentiellement de l'autocomplétion. Pas de fenêtre de chat, pas de conversation : juste des suggestions qui apparaissaient au fil de ma frappe, comme un tab intelligent.

<Callout type="warning">
Le problème, c'est que ces suggestions étaient souvent déconnectées de mon contexte réel. Mon architecture, mes conventions, mes contraintes métier : Copilot n'en avait aucune idée. Le code proposé sentait le Stack Overflow distillé, correct dans l'absolu, mais régulièrement à côté de la plaque dans mon contexte précis.
</Callout>

Au bout d'un an, j'ai fait le bilan honnête : j'étais peut-être un peu plus rapide à taper. Mais plus productif ? Pas vraiment. Et j'ai commencé à me demander si l'IA dans le dev, c'était finalement surtout du hype.

## Cursor : quand l’IA devient un vrai partenaire de développement

C’est en faisant de la veille, comme souvent tard le soir, que je suis tombé sur Cursor. Encore un éditeur, encore une promesse. Et puis j’ai cliqué quand même. Bonne surprise : la transition a été beaucoup plus simple que ce que j’imaginais. Cursor est un fork de VS Code, donc on retrouve directement ses extensions, ses raccourcis, sa config. On n’a pas cette sensation de repartir de zéro.

Les petites frictions arrivent plutôt avec le temps, l’outil évolue vite, très vite. D’une semaine à l’autre, de nouvelles fonctionnalités apparaissent, certains éléments changent de place, l’interface bouge. On finit par s’y habituer, mais ça demande quand même une adaptation continue.

<Callout type="tip">
Ce qui change tout avec Cursor, c'est la façon dont le travail s'organise. Je commence par **Ask**, j'expose mon problème, je discute, j'explore les pistes. Ensuite vient **Plan**, où on affine ensemble ce qui va être implémenté. Et seulement là je passe en **Build**. Je reste aux commandes, mais je collabore vraiment.
</Callout>

<PullQuote>Pour la première fois, j'ai eu l'impression que l'IA était un vrai partenaire de travail, pas juste un correcteur automatique glorifié.</PullQuote>

## Claude Code : un changement de métier

Je suis en train de prendre un nouveau virage, cette fois vers Claude Code. Et celui-là n’a rien à voir avec les précédents.

Là où Cursor m’a appris à collaborer avec l’IA, Claude Code m’apprend à orchestrer. C’est un outil en CLI, et ça change complètement la manière d’aborder le travail. On ne lui demande plus simplement de compléter ou de suggérer, on lui confie de vraies missions. Ça oblige à structurer sa pensée autrement, à développer une vraie méthode de prompt engineering, à raisonner en termes d’agents. On monte clairement d’un cran dans l’abstraction.

Au quotidien, j’alterne entre différents modèles selon le besoin. Certains sont plus à l’aise sur les sujets qui demandent de la précision et du recul, d’autres sont parfaits pour aller vite sur des tâches plus simples. Chaque LLM a ses forces, et apprendre à les utiliser au bon moment fait partie du jeu. Quand le prompt est bien posé, la qualité des réponses reste franchement impressionnante.

<PullQuote>Aujourd'hui, environ 90% de mon code est généré. Mon travail, c'est désormais de la review.</PullQuote>

Après dix ans d’expérience professionnelle, dix ans à mesurer ma valeur à la qualité de ce que j’écris et à la manière dont je construis les choses, le changement est forcément profond. Presque philosophique. Ce qui définissait une partie de mon expertise ne s’est pas effacé, mais déplacé.

## Le nouveau paradigme de la parallélisation

Il y a quelque chose d'autre qui change, peut-être encore plus fondamental.

Pendant près de dix ans, on nous a encouragés à être monotâches. Concentration, profondeur, une chose à la fois : c'était ça, la marque d'un bon dev. Avec le développement agentique, ce paradigme s'inverse. On peut gérer plusieurs sujets en parallèle, déléguer des pans entiers à des agents, travailler à une autre échelle.

C'est à la fois libérateur et vertigineux. Libérateur, parce qu'on passe moins de temps à peser chaque ligne de code : le LLM s'en charge, quand le prompt est bon. Vertigineux, parce qu'il faut apprendre à paralléliser, à organiser le travail en amont différemment, à piloter plutôt qu'à construire.

<Callout type="info">
Le métier de développeur est en train de changer. Pas de disparaître : se redéfinir. Et honnêtement, je suis encore en train d'apprendre ce que ça veut dire.
</Callout>
