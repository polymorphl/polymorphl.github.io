---
title: "From GitHub Copilot to Claude Code: 4 years of AI-assisted development"
slug: "from-copilot-to-claude"
date: "2026-02-25"
tags: ["AI", "Claude Code", "Cursor", "GitHub Copilot"]
summary: "A look back at 4 years of developing with AI: GitHub Copilot, Cursor, and Claude Code. Productivity, agentic development, and how the developer's role is evolving."
readingTime: 5
---

A little over three years ago, I launched GitHub Copilot for the first time. Curious but skeptical, I didn't believe it would transform the way I coded.

I was wrong. But not at all for the reasons I expected.

<Timeline items={[
  { year: "2022", tool: "GitHub Copilot", desc: "Smart autocomplete. A seductive promise, only half kept." },
  { year: "2023", tool: "Cursor", desc: "Conversational mode. A genuine paradigm shift." },
  { year: "2025–", tool: "Claude Code", desc: "Agentic development. A different job entirely." }
]} />

## GitHub Copilot: a false friend for productivity?

In 2022, Copilot was essentially autocomplete. No chat window, no conversation, just suggestions that appeared as you typed, like a smart tab key.

<Callout type="warning">
The problem was that those suggestions were often disconnected from my actual context. My architecture, my conventions, my business constraints: Copilot had no idea. The proposed code felt like distilled Stack Overflow, technically correct in the abstract, but regularly missing the mark in my specific context.
</Callout>

After a year, I did an honest review: I was maybe a little faster at typing. But more productive? Not really. And I started to wonder if AI in development was mostly hype after all.

## Cursor: when AI becomes a real development partner

It was while doing some late-night tech research, as usual, that I stumbled upon Cursor. Another editor, another promise. I clicked anyway. Pleasant surprise: the transition was much smoother than I expected. Cursor is a VS Code fork, so you get your extensions, shortcuts, and config right out of the box. There's no feeling of starting from scratch.

The small friction points come later, the tool evolves fast, very fast. Week to week, new features appear, things move around in the interface, the UI shifts. You get used to it, but it does require continuous adaptation.

<Callout type="tip">
What changes everything with Cursor is how work gets organized. I start with **Ask**, lay out my problem, discuss, explore options. Then comes **Plan**, where we refine together what's going to be implemented. Only then do I move to **Build**. I'm still in control, but I'm genuinely collaborating.
</Callout>

<PullQuote>For the first time, I felt like AI was a real work partner not just a glorified autocorrect.</PullQuote>

## Claude Code: a change of profession

I'm in the middle of a new shift, this time toward Claude Code. And this one is unlike anything before.

Where Cursor taught me to collaborate with AI, Claude Code is teaching me to orchestrate. It's a CLI tool, and that completely changes how you approach the work. You're no longer just asking it to complete or suggest, you're delegating real missions. It forces you to structure your thinking differently, to develop a genuine prompt engineering method, to reason in terms of agents. You're clearly moving up a level of abstraction.

Day to day, I alternate between different models depending on the need. Some are better suited for tasks requiring precision and depth; others are perfect for moving fast on simpler work. Each LLM has its strengths, and learning to use the right one at the right time is part of the game. When the prompt is well crafted, the quality of the responses is genuinely impressive.

<PullQuote>Today, roughly 90% of my code is generated. My work is now review.</PullQuote>

After a decade of professional experience, during which I measured my value by the quality of what I wrote and built, the change feels profound. Almost philosophical. What once defined part of my expertise hasn’t disappeared; it has simply shifted.

## The new paradigm of parallelization

Something else is changing, perhaps even something more fundamental.

For nearly ten years, we were encouraged to focus on one task at a time. Focus, depth, one thing at a time: that was the hallmark of a good developer. 

With agentic development, that paradigm inverts. You can manage multiple topics in parallel, delegate entire chunks of work to agents, operate at a different scale.

It’s both liberating and dizzying. Liberating because you spend less time weighing every line of code; the LLM handles that when the prompt is right. Dizzying because you have to learn to parallelize, to organize work differently from the start, to pilot rather than build.

<Callout type="info">
The developer’s role is changing. It’s not disappearing; it’s redefining itself. And honestly, I’m still figuring out what that means.
</Callout>
